//
//  NetworkOperation.swift
//  Radiant Tap Essentials
//
//  Copyright © 2017 Radiant Tap
//  MIT License · http://choosealicense.com/licenses/mit/
//

import Foundation

/// Subclass of [AsyncOperation](https://github.com/radianttap/Swift-Essentials/blob/master/Operation/AsyncOperation.swift)
///	that handles most aspects of direct data download over network.
///
///	In the simplest case, you can supply just `URLRequest` and a `Callback` which accepts `NetworkPayload` instance.
///	Or you can also supply custom `URLSessionConfiguration` just for this request (otherwise `.default` will be used).
///	Or `URLSession` instance if you have it somewhere else.
///
///	If you don't supply URLSession instance, it will internally create one and use it, just for this one request.
///	This URLSession will handle server-trust HTTPAuthenticationChallenge, using `urlSession.serverTrustPolicy`.
///	Note: if you supply URLSession instance, you are responsible to handle HTTPAuth challenges.
///
///	If you are using `.background` URLSessionConfiguration, you **must** use URLSessionDelegate
///	thus you must supply URLSession instance to the `init`.
final class NetworkOperation: AsyncOperation {
	typealias Callback = (NetworkPayload) -> Void

	required init() {
		fatalError("Use the `init(urlRequest:urlSessionConfiguration:callback:)`")
	}


	/// Designated initializer, allows to create one URLSession per Operation.
	///
	/// - Parameters:
	///   - urlRequest: `URLRequest` value to execute
	///   - urlSessionConfiguration: `URLSessionConfiguration` for this particular network call. Fallbacks to `default` if not specified
	///   - callback: A closure to pass the result back
	init(urlRequest: URLRequest,
		 urlSessionConfiguration: URLSessionConfiguration = URLSessionConfiguration.default,
		 callback: @escaping (NetworkPayload) -> Void)
	{
		self.payload = NetworkPayload(urlRequest: urlRequest)
		self.callback = callback
		self.urlSessionConfiguration = urlSessionConfiguration
		super.init()

		processHTTPMethod()
	}

	/// Designated initializer, uses supplied URLSession instance. Always uses completionHandler form of URLSessionDataTask
	///
	/// - Parameters:
	///   - urlRequest: `URLRequest` value to execute
	///   - urlSession: URLSession instance to use for this Operation
	///   - callback: A closure to pass the result back
	init(urlRequest: URLRequest,
		 urlSession: URLSession,
		 callback: @escaping (NetworkPayload) -> Void)
	{
		self.payload = NetworkPayload(urlRequest: urlRequest)
		self.callback = callback
		self.urlSessionConfiguration = urlSession.configuration
		self.localURLSession = urlSession
		super.init()

		processHTTPMethod()
	}

	fileprivate(set) var payload: NetworkPayload
	private(set) var callback: Callback

	///	Configuration to use for the URLSession that will handle `urlRequest`
	private(set) var urlSessionConfiguration : URLSessionConfiguration

	///	URLSession that will be used for this particular request.
	///	If you don't supply it in the `init`, it will be created locally for this one request
	fileprivate var localURLSession: URLSession!
	fileprivate(set) var shouldCleanupURLSession = false

	///	Actual network task, generated by `localURLSession`
	fileprivate(set) var task: URLSessionDataTask?

	///	By default, Operation will not treat empty data in the response as error.
	///	This is normal with HEAD, PUT or DELETE methods, so this value will be changed
	///	based on the URLRequest.httpMethod value.
	///
	///	If you want to enforce a particular value, make sure to set it
	///	*after* you create the NetworkOperation instance but *before* you add to the OperationQueue.
	var allowEmptyData: Bool = true
	fileprivate var incomingData = Data()


	//	MARK: AsyncOperation

	/// Set network start timestamp, creates URLSessionDataTask and starts it (resume)
	override func workItem() {
		payload.start()

		if localURLSession == nil {
			//	Create local instance of URLSession, no delegate will be used
			localURLSession = URLSession(configuration: self.urlSessionConfiguration,
										 delegate: self,
										 delegateQueue: nil)
			//	we need to finish and clean-up tasks at the end
			shouldCleanupURLSession = true
		}

		//	Create task, using `completionHandler` form
		task = localURLSession.dataTask(with: payload.urlRequest, completionHandler: {
			[weak self] data, response, error in
			guard let `self` = self else { return }

			self.payload.response = response as? HTTPURLResponse
			if let e = error {
				self.payload.error = .urlError(e as? URLError)

			} else {
				self.payload.data = data

				if let data = data {
					if data.isEmpty && !self.allowEmptyData {
						self.payload.error = .noData
					}
				} else {
					if !self.allowEmptyData {
						self.payload.error = .noData
					}
				}
			}

			self.finish()
		})
		//	start the task
		task?.resume()
	}

	fileprivate func finish() {
		if shouldCleanupURLSession {
			//	this cancels immediatelly
//			localURLSession.invalidateAndCancel()
			//	this will allow background tasks to finish-up first
			localURLSession.finishTasksAndInvalidate()
		}

		payload.end()
		markFinished()

		callback(payload)
	}

	internal override func cancel() {
		super.cancel()

		task?.cancel()
		payload.error = .cancelled

		finish()
	}

	fileprivate func processHTTPMethod() {
		guard
			let method = payload.originalRequest.httpMethod,
			let m = NetworkHTTPMethod(rawValue: method)
		else { return }

		allowEmptyData = m.allowsEmptyResponseData
	}
}


extension NetworkOperation: URLSessionDataDelegate {

	func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
		urlSession(session, didReceive: challenge, completionHandler: completionHandler)
	}

	func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
		if isCancelled {
			completionHandler(URLSession.AuthChallengeDisposition.cancelAuthenticationChallenge, nil)
			return
		}

		if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
			let trust = challenge.protectionSpace.serverTrust!
			let host = challenge.protectionSpace.host
			guard session.serverTrustPolicy.evaluate(trust, forHost: host) else {
				completionHandler(URLSession.AuthChallengeDisposition.rejectProtectionSpace, nil)

				let urlError = NSError(domain: NSURLErrorDomain,
									   code: URLError.userCancelledAuthentication.rawValue,
									   userInfo: nil ) as? URLError
				payload.error = .urlError( urlError )
				finish()
				return
			}

			let credential = URLCredential(trust: trust)
			completionHandler(URLSession.AuthChallengeDisposition.useCredential, credential)
			return
		}

		completionHandler(URLSession.AuthChallengeDisposition.performDefaultHandling, nil)
	}
}

